# ================================================================================
#
#   GENOA v3: the Generator of Optimized Atmospheric chemical mechanisms
#
#   Copyright (C) 2025 CE-CERT (UCR) - ACOM (NCAR) - CEREA (ENPC) - INERIS
#
#   Distributed under the terms of the GNU General Public License v3 (GPLv3).
#
# ================================================================================

"""
This module provides functions to input and output of chemical mechanisms.
"""

import os
from collections import OrderedDict
from typing import Optional

from .constants import SNAME
from .logger import setup_logger
from .mechanism_update import update_mechanism
from .mcm import process_mcm_facsmile_reactions, process_mcm_species
from .gecko_in import process_gck_reactions_and_species
from .reaction import Reaction
from .setting_global import get_attrs_from_settings
from .species import Species, add_basic_to_species_list
from .utils import get_mech_files


# Logger
logger = setup_logger(__name__)


def read_and_update_mechanism(rfile: str, sfile: str, rtype: str, stype: str, uopt: Optional[dict] = None) -> list:
    """
    Read chemical mechanisms from given reaction and species files.
    Options to update mechanism can be provided in uopt:
    - check_rate: bool, check reaction rates
    - clean: str, cleaning mode ("wsps", "wpvoc", "wgen")
    - merge: bool, whether to merge reactions
    - split: bool, whether to split reactions
    - check_kept: set, species to keep in the mechanism
    """

    # Get options
    # Default: {"check_rate": True, "clean": "wsps", "merge": False, "split": False, "check_kept": None}
    if uopt is None:
        uopt = {}

    # Read
    reactions, species = _read_mech_from_files(rfile, sfile, rtype, stype)

    # Update and return [reactions, species, is_valid]
    return update_mechanism(reactions, species, uopt)


def read_and_update_genoa_mech(mech_path: str, mech_name: str, uopt: Optional[dict] = None) -> list:
    """Read mechanism from GENOA files and update it."""

    # Get options
    # Default: {with_folder": True, "check_rate": False, "clean": "wsps"
    #  "merge": False, "split": False, "check_kept": None}
    if uopt is None:
        uopt = {}

    # Get mechanism filenames
    rcn_file, sps_file = get_mech_files(mech_path, mech_name, uopt.pop("with_folder", True))

    # Read mechanism lists
    reactions, species = _read_mech_from_files(rcn_file, sps_file, "GENOA", "GENOA")

    # Update mechanism and return
    return update_mechanism(reactions, species, uopt)


def _read_mech_from_files(rcn_file: str, sps_file: str, rcn_type: str, sps_type: str) -> list:
    """Read and return reaction and speices lists from given reaction and species files."""

    # Maping
    reaction_processors = {
        "SSH": _process_reaction_file,
        "GENOA": _process_reaction_file,  # GENOAv3 uses SSH format
        "MCM": process_mcm_facsmile_reactions,  # Default MCM uses FACSMILE
        "FACSMILE": process_mcm_facsmile_reactions,
    }
    species_processors = {
        "MCM": process_mcm_species,
        "SSH": _process_species_file,
        "GENOA": _process_species_file,  # GENOAv3 uses SSH format
    }

    # Read files
    if rcn_type == "GECKO":  # GECKO-A: process folder
        reactions, species = process_gck_reactions_and_species(rcn_file)
        logger.info("Read reactions and species from GECKO-A folder: %s", rcn_file)
    else:

        # Process species list
        if sps_type not in species_processors:
            raise ValueError(f"Unknown species type {sps_type}.")
        species = species_processors[sps_type](sps_file)

        # Process reaction list
        if rcn_type not in reaction_processors:
            raise ValueError(f"Unknown reaction type {rcn_type}.")
        reactions = reaction_processors[rcn_type](rcn_file)
        logger.info("Read reactions (%s) from %s & species (%s) from %s", rcn_type, rcn_file, sps_type, sps_file)

    return [reactions, species]


def _process_reaction_file(reaction_file: str):
    """Processes a reaction file generated by GENOAv3. Also in SSH-aerosol format."""

    reactions = []
    separator = "%==="

    # Read basic species to define basic reactions
    basic_dict = get_attrs_from_settings({SNAME.SETUP: "basicspecies_dict"})

    with open(reaction_file, "r", encoding="utf-8") as file:
        # Remove comments and split by separator
        parts = file.read().split(separator)[1:]
        for part in parts:
            # Find a reaction with kinetic
            if "->" in part and "KINETIC" in part:
                # Add a new reaction
                reactions.append(Reaction())
                rcn = reactions[-1]
                # Read reaction
                rcn.from_rcn(separator + part)
                # Update reaction status
                rcn.update_status(basic_dict)

    return reactions


def _process_species_file(species_file: str) -> list:
    """Processes a species file generated by GENOAv3"""

    if not species_file or not os.path.exists(species_file):
        raise ValueError(f"Species file {species_file} does not exist.")

    # Get settings
    basic_dict = get_attrs_from_settings({SNAME.SETUP: "basicspecies_dict"})

    # Process input file
    with open(species_file, "r", encoding="utf-8") as f:
        lines = f.read().splitlines()
    splists, sname = OrderedDict(), None
    for i, line in enumerate(lines):
        if 'name\t"' in line:  # Find s species
            # For last species
            end_idx = i - 1
            if sname is not None:
                splists[sname].append(end_idx)
            # For new species
            start_idx = i
            sname = line.split('"', 1)[1].replace('"', "").strip()
            if sname in splists:
                raise ValueError(f"Find repeat species {sname} in {species_file}")
            splists[sname] = [start_idx]

    # Add last index
    if splists:
        splists[sname].append(len(lines) - 1)
    else:
        raise ValueError(f"Can not read species info from {species_file}.")

    # Process species
    species, sps_dict = [], {}
    for sp in splists:  # Find in species list
        # Get ranges for inpput properties
        irange = splists[sp]
        # Add new species: status = 1
        isp = Species(name=sp)
        isp.read_from_lines(lines[irange[0] : irange[1]])
        species.append(isp)
        sps_dict[sp] = species[-1]

    # Add basic species
    add_basic_to_species_list(species, sps_dict, basic_dict)

    return species
