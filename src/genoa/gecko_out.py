# ================================================================================
#
#   GENOA v3: the Generator of Optimized Atmospheric chemical mechanisms
#
#   Copyright (C) 2025 CE-CERT (UCR) - ACOM (NCAR) - CEREA (ENPC) - INERIS
#
#   Distributed under the terms of the GNU General Public License v3 (GPLv3).
#
# ================================================================================


"""
This module contains functions to convert GECKO-A output files.
"""

import os
from typing import Optional

from .constants import PRC_ST, PRC_FL
from .gecko_cst import NPERO, LENSP, MAX_LINES, MAX_LINE_LEN, GRCT_DICT, NSPACE, GRO2_GRP, GARR3, EXTRA_KEYS
from .logger import setup_logger
from .reaction import get_reactions_with_fake_species
from .simulation_gecko import run_interp

# Logger
logger = setup_logger(__name__)


def mech_output_to_gecko(path: str, chem: str, reactions: list, species: list, fake_sps: dict) -> bool:
    """
    Converter: Write GECKO-A files for a GENOA mechanism.
      Mechanism will be saved in a folder: path/chem
    - indat.mech: mechanism file
    - indat.li: binary file - generated by INTERP30
    - indat.ro2: RO2 file
    - pvap.sat: aerosol properties file
    - Tg.dat: aerosol properties file
    - mdv.dat: aerosol properties file
    Return True if successful.
    """

    add_pratio = False
    w_mechname = True
    out_ro2_one = True

    os.makedirs(path, exist_ok=True)  # Create folder

    # Initialize counters (SIZE as generated + 1)
    nsps, nrcns, npho_rcn, ntb_rcn, no2_rcn, next_rcn = 2, 1, 1, 1, 0, 1
    nro2_rcn, nfall_rcn, niso_rcn, naero_rcn, nwall_rcn, nstio_rcn = 1, 1, 1, 1, 1, 1
    nrsps = 0  # Size for output
    numrts, numrcnwrt, numpdtwrt, numrtfncs = 0, 0, 0, 0  # Product ratios
    gas_lines, aero_lines, wall_lines = [], [], []
    ro2s = {i: [] for i in range(1, 1 + NPERO)}  # RO2 groups
    aero_list, lrcn_sps, rcn_lines = [], [], []  # Aerosols, rcn line from species list, rcn line

    # Get output filenames
    fnames = get_gck_filenames(chem if w_mechname else "indat", add_pratio)

    arr3_default = " " * 20 + " ".join(GARR3) + "\n"
    win_default = " " * 20 + "1.111E-3  0.0  0.\n    WIN / 1.20E-04 /\n"
    wout_default = " " * 20 + "1.111E-3  0.0  0.\n    WOU / 1.20E-04 /\n"

    # Get species outputs
    for i, s in enumerate(species):
        if not s.status:
            continue
        if "RO2pool" in s.name:
            continue  # Skip RO2 pool used for SSH smls
        if len(s.name) > LENSP - 1:
            raise ValueError(f"Species name {s.name} exceeds limit {LENSP-1}.")
        # Gas species
        gas_lines.append(f"G{s.name:16}/{s.mass:.1f}/\n")
        nsps += 1  # Count gas
        if s.status == 1:
            nrsps += 1  # Count reducible species
        if s.condensable:
            aero_list.append(s)
            aero_lines.append(f"A{s.name:16}/{s.mass:.1f}/\n")  # Aerosol
            # Add AIN and AOU reactions
            lrcn_sps.append(f"G{s.name} + AIN => A{s.name}" + arr3_default)
            lrcn_sps.append(f"A{s.name} + AOU => G{s.name}" + arr3_default)
            nsps += 1  # Count aero
            naero_rcn += 1  # Gas <-> Particles
            nrcns += 2  # Count aerosol reactions
        elif s.RO2:
            ro2s[s.RO2].append(f"G{s.name:16}")  # RO2
        # Wall species
        if s.wall_loss:
            wall_lines.append(f"W{s.name:16}/{s.mass:.1f}/\n")
            # Add wall reactions
            nwall_rcn += 1  # Gas <-> Wall
            # Add WIN and WOU reactions
            lrcn_sps.append(f"G{s.name} + WIN => W{s.name}" + win_default)
            lrcn_sps.append(f"W{s.name} + WOU => G{s.name}" + wout_default)
            nsps += 1  # Count wall sps
            nrcns += 2  # Count wall reactions

    # naero = len(aero_list)

    # Add fake species if needed
    if fake_sps:
        current_reactions = get_reactions_with_fake_species(reactions, fake_sps, "f")
        # len name <= 8 !
        gas_lines.extend(f"Gf{s:16}/{imw:.1f}/\n" for s, imw in fake_sps.items())
        nsps += len(fake_sps)
    else:
        current_reactions = reactions

    # Get reaction outputs
    # nrcn0 = nrcns  # Record # before reactions
    for rcn in current_reactions:
        if rcn.status <= 0:
            continue
        # Get GECKO reaction line and type
        rcn_line, itype = to_gck_rcn_line_and_type(rcn)
        # Update reaction list
        rcn_lines.append(rcn_line + "\n")
        nrcns += 1

        # if rcn.rt_fnc:  # Check product ratio
        #     if itype:
        #         raise ValueError(f"Not support pratio with itype: {rcn_line} {itype}")
        #     i = len(rcn.rt_fnc["rates"])
        #     numpdtwrt = max(numpdtwrt, len(rcn.rt_fnc) - 2)  # max pdts
        #     numrtfncs = max(numrtfncs)  # max rates
        #     numrts += i  # No.rates
        #     numrcnwrt += 1  # No.reactions

        # Update counts from reaction list
        if not itype:
            continue
        if itype == "HV":
            npho_rcn += 1  # Photolysis
        elif itype == "TBODY":
            ntb_rcn += 1  # Third body
        elif itype == "ISOM":
            niso_rcn += 1  # Isomerization
        elif itype == "FALLOFF":
            nfall_rcn += 1  # Fall off
        elif itype == "OXYGEN":
            no2_rcn += 1  # O2 reactions
        elif "PERO" in itype and itype != "MEPERO":
            nro2_rcn += 1  # RO2-RO2 reactions (not MEPERO)
        elif itype == "EXTRA":
            next_rcn += 1  # Extra reactions
        # elif 'EXTRA / /' in rcn_line: nstio_rcn += 1 # Variable stoichiometry

    # Size file
    size_info = [
        "SIZE        ! as generated + 1",
        f"{nsps:>10}  ! total number of species",
        f"{nrcns:>10}  ! total number of reactions",
        f"{npho_rcn:>10}  ! HV reactions",
        f"{ntb_rcn:>10}  ! third body M reactions",
        f"{no2_rcn:>10}  ! O2 reactions",
        f"{next_rcn:>10}  ! EXTRA reactions",
        f"{nro2_rcn:>10}  ! CH3O2/RO2 reactions",
        f"{nfall_rcn:>10}  ! fall off reactions",
        f"{niso_rcn:>10}  ! R(O.) isomerization reactions",
        f"{naero_rcn:>10}  ! gas <-> part. equilibrium",
        f"{nwall_rcn:>10}  ! gas <-> wall equilibrium",
        f"{nstio_rcn:>10}  ! variable stoi. coef. reactions",
    ]

    # Check before output
    # Add product ratio info to size file
    if add_pratio:
        size_info.append(f"{numrts:>8} {numrcnwrt:>8} {numpdtwrt:>4} {numrtfncs:>4}  ! product ratio info")
    elif numrcnwrt > 0:
        raise ValueError("Error: product ratio info found but add_pratio is False.")

    ## Write [chem].mech file -> [chem].bin -> indat.li
    with open(os.path.join(path, fnames["mech"]), "w", encoding="utf-8") as f:
        ## Size -> size.dum
        f.writelines(line + "\n" for line in size_info)

        ## Gas species list -> gasspe.dum - always exist
        f.write("SPECIES\nPHASE: START GAS\n")  # Header
        f.writelines(gas_lines)  # Species list
        f.write("PHASE: END GAS\n")  # Footer

        ## Particles species list -> partspe.dum - optional
        f.write("PHASE: START PART.\n")  # Header
        if aero_lines:
            f.writelines(aero_lines)
        f.write("PHASE: END PART.\n")  # Footer

        ## Wall phase species list -> wallspe.dum - optional
        f.write("PHASE: START WALL\n")  # Header
        if wall_lines:
            f.writelines(wall_lines)
        f.write("PHASE: END WALL\nEND SPECIES\n")  # Footer

        ## Reaction list -> reactions.dum
        f.write("!----------------\nREACTIONS\n!----------------\n")  # Header
        f.writelines(rcn_lines)
        f.writelines(lrcn_sps)
        f.write("END\n")  # Footer

    # logger.info("Finished writing mechanism %s to %s.", chem, os.path.join(path, fnames["mech"]))

    # Run INTERP30 to convert .mech file to .bin file
    # Remove old file if exists
    if os.path.exists(os.path.join(path, fnames["bin"])):
        os.remove(os.path.join(path, fnames["bin"]))
    cmd_list_add = [chem if w_mechname else "-"]
    if add_pratio:
        cmd_list_add.append("1")

    if not run_interp(path, cmd_list_add, fnames["bin"]):
        return False

    # Write other files needed for GECKO-A box model
    _write_ro2_file(path, fnames["ro2"], ro2s, out_ro2_one)

    # Write aerosol properties
    _write_aerosol_files(path, fnames["aeros"], aero_list)

    # return [nrcns - nrcn0, nsps, nrsps, naero]
    return True


def get_gck_filenames(chem: str, add_pratio: bool = False) -> dict:
    """Get GECKO-A file names for mechanism generation."""

    # Output [chem].xxx or indat.xxx
    names = {"bin": f"{chem}.li", "mech": f"{chem}.mech", "ro2": f"{chem}.ro2"}

    # Aerosol files
    if chem == "indat":
        names["aeros"] = {"psat": "pvap.sat", "tg": "Tg.dat", "mdv": "vdiffusion.dat"}
    else:
        names["aeros"] = {"psat": f"{chem}.pvap", "tg": f"{chem}.Tg", "mdv": f"{chem}.mdv"}

    # Add product ratio info
    if add_pratio:
        for i in ["bin", "mech"]:
            names[i] = f"{names[i]}.genoa"

    return names


def to_gck_rcn_line_and_type(rcn) -> list:
    """Output the GECKO-A format for a reaction object."""

    # Reactants
    rcts = []
    for s, rt in rcn.reactants.items():
        for _ in range(int(rt)):
            rcts.append("G" + s)
    rct = " + ".join(sorted(rcts))

    # Products
    pdts = []
    for s in sorted(rcn.products.keys()):
        rt = round(rcn.products[s], 5)
        rt0 = round(rt)
        if rt <= 0.0:
            logger.warning("Find ratio <= 0 for %s in %s", s, rcn.to_line_wo_kinetic())
            continue
        if abs(rt - rt0) < 1e-9:
            rt = int(rt0)
            pdts.append(f"{rt} G{s}" if rt != 1 else f"G{s}")
        else:  # non-int ratio
            rt = f"{rt:{PRC_ST}}".rstrip("0").rstrip(".")  # Remove trailing "0" and "."
            pdts.append(f"{rt} G{s}")

    # Kinetic ratios and type
    rline, itype = to_gck_kinetic_line(rcn)

    # Update reactants if need
    if itype:
        rct = f"{rct} + {itype} => "
    else:
        rct = f"{rct} => "

    rcnline = _get_rcn_line(rct, pdts, rline)

    # Add product ratio info if need

    return [rcnline, itype]


def to_gck_kinetic_line(rcn) -> list:
    """Output the GECKO-A format for kinetic."""

    # Get reaction note by checking mainkey
    mainkey = rcn.rate.mainkey
    coefs_str = rcn.rate.coefs_str
    ratio = rcn.rate.ratio
    if mainkey == "ARR":
        rnote = ""
    elif mainkey == "PHOT":  # key / index & ratio /
        rnote = f"\n    HV / {' '.join(coefs_str)} 1.00 /"
    elif mainkey == "FALLOFF":
        rnote = f"\n    FALLOFF / {' '. join(coefs_str[3:])} /"
    elif mainkey in EXTRA_KEYS:  # Update key for EXTRA
        subkey = EXTRA_KEYS[mainkey]
        if subkey == 200:
            rnote = f"\n    ISOM / {' '.join(coefs_str[3:])} /"
        else:
            rnote = f"\n    EXTRA / {subkey} {' '.join(coefs_str[3:])} /"
    else:
        raise ValueError(f"Mainkey {mainkey} is not supported in GECKO-A.")

    # Get arrhenius(3)
    arr3 = GARR3 if mainkey == "PHOT" else coefs_str[0:3]
    if ratio != 1.0:
        arr3[0] = f"{float(arr3[0]) * ratio:{PRC_FL}}"

    return [" ".join(arr3) + rnote, _get_rctname(rcn.rate.key_str, rcn.rate.ro2, rcn.rate.tb)]


def _get_rcn_line(rct, pdts, kline) -> str:
    """Get reaction line with reactants, products, and kinetic info. Add line break if needed."""

    npdts = len(pdts)

    if npdts == 0:  # No products
        return rct + "NOTHING" + NSPACE + kline

    if npdts == 1:  # Only one product
        return rct + pdts[0] + NSPACE + kline

    rlines = [rct]
    current_len = len(rct)
    nline = 1

    for i in range(npdts - 1):
        part = pdts[i] + " + "
        npart = len(part)
        if current_len + npart + len(pdts[i + 1]) + 3 > MAX_LINE_LEN:  # New line
            rlines.append("\n")
            current_len = 0
            nline += 1
        rlines.append(part)
        current_len += npart

    # Handle the last product and kinetic info
    last = pdts[-1]
    # Get length of kinetic info
    if "\n" in kline:
        nkline = kline.index("\n")
        nline += 1  # Kinetic info contains a new line
    else:
        nkline = len(kline)
    if current_len + len(last) + nkline + 4 > MAX_LINE_LEN:  # New line
        rlines.append("\n" + last + NSPACE + kline)
        nline += 1
    else:  # Min len between last product and kinetic info is 4
        space = min(MAX_LINE_LEN - current_len - nkline, len(NSPACE))
        rlines.append(last + " " * space + kline)

    if nline > MAX_LINES:
        logger.error("Reaction line %d > %d. Check %s", nline, MAX_LINES, "".join(rlines))

    return "".join(rlines)


def _get_rctname(key: str, ro2: Optional[str], tb: Optional[str]) -> Optional[str]:
    """Get additional reactant name"""

    if tb:
        return "OXYGEN" if tb == "O2" else "TBODY"  # Third body

    if ro2:
        return GRO2_GRP[int(ro2) - 1]  # Return RO2 group name

    if key in GRCT_DICT:
        return GRCT_DICT[key]  # Return reaction type

    if "EXTRA" in key:
        return "EXTRA"

    raise ValueError(f"Unknown key {key} in reaction. Check {key}.")


def _write_aerosol_files(path: str, aeros: dict, aero_list: list) -> None:
    """
    Output gecko-a aerosol related files:
      [chem].nan.sat -> pvap.sat
      [chem].Tg -> Tg.dat
      [chem].mdv -> vdiffusion.dat -> mdv.dat
    """

    count_line = f"{len(aero_list):>10}  ! number of record (species) in the file\n"

    # Write pvap.sat
    with open(os.path.join(path, aeros["psat"]), "w", encoding="utf-8") as f:
        f.write(count_line + "TREF 298.0\n")
        f.writelines(f"G{s.name:16}    {s.psat_atm:9.3E}    {s.dhvap_kj:9.3E}\n" for s in aero_list)
        f.write("END\n")

    # Write Tg.dat
    with open(os.path.join(path, aeros["tg"]), "w", encoding="utf-8") as f:
        f.write(count_line)
        f.writelines(f"G{s.name:16}    {s.tg:.2f}\n" for s in aero_list)
        f.write("END\n")

    # Write mdv.dat
    with open(os.path.join(path, aeros["mdv"]), "w", encoding="utf-8") as f:
        f.write(count_line)
        f.writelines(f"G{s.name:16}    {s.dvol:.2f}\n" for s in aero_list)
        f.write("END\n")


def _write_ro2_file(path: str, ro2f: str, ro2s: list, out_ro2_one: bool) -> None:
    """Write down ro2 information in [ro2f].ro2 or [ro2f].ro2.1 to [ro2f].ro2.NPERO"""

    # Output one file
    if out_ro2_one:
        with open(os.path.join(path, ro2f), "w", encoding="utf-8") as f:
            f.write("  ".join(f"{len(ro2s[i])}" for i in range(1, NPERO + 1)) + "\n")
            f.writelines(f"{s:16} {i}\n" for i in range(1, 10) for s in ro2s[i])
            f.write("END\n")

    # Output multiple RO2 files
    else:
        for i in range(1, NPERO + 1):
            with open(os.path.join(path, f"{ro2f}.{i}"), "w", encoding="utf-8") as f:
                f.write(f"{len(ro2s[i]):>10}  ! number of record (RO2 species) in the file\n")
                if ro2s[i]:
                    f.writelines(line + "\n" for line in ro2s[i])
                f.write("END\n")
