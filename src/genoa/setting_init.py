# ================================================================================
#
#   GENOA v3: the Generator of Optimized Atmospheric chemical mechanisms
#
#   Copyright (C) 2025 CE-CERT (UCR) - ACOM (NCAR) - CEREA (ENPC) - INERIS
#
#   Distributed under the terms of the GNU General Public License v3 (GPLv3).
#
# ================================================================================

"""
This module contains the default setting and options for running GENOA.
"""

from typing import List, Dict, Any, Optional, Union

from attrs import define, field, asdict

from .logger import setup_logger
from .folder_path import FolderPath
from .reduction_setting import tbr_order
from .record import RecordOption

# from simulation_init import RunSmlSetting

# Logger
logger = setup_logger(__name__)


@define(slots=True)
class GlobalSetting:
    """General settings with default values."""

    # Actions that can be processed by GENOA. ACNS: [NEW, SML, TRN, TST, TBR, PST]
    actions: Optional[list] = None

    # Mechanism related settings
    id_mech: str = "test"  # Mechanism id
    prefix: str = "T"  # Mechanism prefix
    mech_name: str = "Ttest"  # Mechanism name
    primary_vocs: List[str] = field(factory=list)  # Priamry vocs where reactions starts

    # Directories
    path_workplace: str = "./output/work"  # Directory to run GENOA
    path_read_mech: Optional[str] = None  # Directory to read chemical mechanisms
    path_sav_mech: str = "./output/mechs"  # Directory to read/save chemical mechanisms
    path_sav_res: str = "./output/results"  # Directory to save 0D simulation results
    path_init_cond: str = "./output/initial"  # Directory to read initial conditions

    # Simulation setups
    ncpu: Optional[int] = None  # Number of CPUs for parallel computing

    ## From here may need to move to simulation !!!
    boxmodel: str = "GECKO"  # Box model used for simulation & result evaluation
    # Available: SSH or GECKO

    basic_species_files: List[str] = field(factory=list)  # Basic species files

    # Time settings
    start_t: List[int] = [0]  # Starting time in seconds
    total_t: List[int] = [432000]  # Total time in seconds (e.g., 5 days)
    delta_t: List[int] = [3600]  # Time step in seconds (e.g., 1 hour)
    # Simulation dates in format [year, month, day]
    dates: List[List[int]] = [[2015, 1, 1]]

    # Basic species dictionary - species name: molar mass
    # These species will not participate in reduction
    basicspecies_dict: Dict[str, float] = field(factory=dict)

    # Simulation time series (built in the code)
    time_settings: List[List[float]] = field(factory=list)

    # Reference concentrations
    refconc_file: Optional[str] = None  # File to read reference concentrations
    refconc_wfake: bool = False  # Use fake species for radicals or not
    refconc_save: bool = False  # Save reference concentrations as npz file

    err_ref_str: Optional[str] = None  # Error reference files as a string

    # Tracers
    # dict: {"loss": {sps1: tracer1, ..}, "gain": {sps2: tracer2, ..}}
    # list: [gain, loss, removal]
    gain_tracers: Dict[str, str] = field(factory=dict)  # Gain tracers
    loss_tracers: Dict[str, str] = field(factory=dict)  # Loss tracers
    tracers: Optional[list] = None  # [gain, loss]


@define(slots=True)
class NewMechOption:
    """Options for building a new mechanism."""

    update_mode: str = "wsps"  # Update model: "wsps", "wpvoc", "wgen"
    if_merge: int = 0  # Merge reactions or not

    # Read mechansim
    speciesfile: str = ""  # Species file
    # Currently supported: GECKO, MCM, SSH, KPP, FACsmiles

    speciestype: str = "SSH"  # Species file type
    reactionfile: str = ""  # Reaction file
    reactiontype: str = "SSH"  # Reaction file type

    # File that saves functional group decomposition information generated by SOAP
    soapfile: str = ""

    # Update species from SMILES or not - currently for GECKO only
    update_from_smiles: int = 0

    add_fake_radical: int = 0  # Add fake radical species or not
    output_modes: Optional[list] = None  # Output modes

    # Aerosol related
    """
    Saturation vapor pressure computation method from UManSysProp, Topping et al., 2016
    - Available options: "VP0BP0", "VP1BP0", "VP0BP1", "VP0BP2", "evap", "simpol"
      "VP" for vapor point : 0 - Nannoolal et al., 2008; 1 - Myrdal and Yalkowsky, 1997
      "BP" for boiling point: 0 - Nannoolal et al., 2004; 1 - Stein and Brown, 1994; 2 - Joback and Reid, 1987
      "evap": EVAPORATION of Compernolle et al. (2011)
      "simpol": SIMPOL.1 of Pankow and Asher (2008)
    """
    vptype: str = "VP0BP0"  # Saturation vapor pressure method
    psat_nvoc: float = 0.0  # Non-volatile if Psat < psat_nvoc in atm
    psat_svoc: float = 0.0  # Non-condensable if Psat > psat_svoc in atm


@define(slots=True)
class SMLOption:
    """Options for running a simulation."""

    init_set_str: str = ""  # Initial concentration list
    init_id0: int = 0  # Starting initial set id
    error_species_str: str = ""  # Species list for error computation besides total soas.
    result_mode: int = 1  # Output mode


@define(slots=True)
class SSHOption:
    """Options for running SSH-aerosol simulations."""

    path: str = "./vendor/SSH-aerosol"  # Path to SSH-aerosol box model
    cmd_build: str = "./clean > tmptoto 2>&1 && ./compile > tmptoto 2>&1"  # Command to build SSH-aerosol
    namelist: str = "./data/ssh-aerosol-files/namelist_new"  # Default namelist
    nsim: int = 1  # Number of parallel simulations

    # SSH-aerosol specific options
    aero_file: str = "./data/ssh-aerosol-files/species-list-aer-genoa.dat"  # Default aerosol species list

    # Initial conditions
    tag_init_hourly: int = 0  # Use hourly initial conditions (add _[n]h) or not
    tag_cst_profile: int = 0  # Use constant profiles (gas.cst & aero.cst) or not
    tag_time_monthly: int = 1  # Update time settings with month or not

    # Output options - used when result_mode is 0
    out_gas_str: Optional[str] = None  # Output gas-phase species list as a string, separated by ','
    out_aero_str: Optional[str] = None  # Output aerosol species list as a string, separated by ','
    out_all_aeros: int = 0  # Output all aerosol species lists ([chem.aer.1st], [chem.aer]) or not

    """
    Additional initial sets besides the one provided in path_init_cond
    The file should contain a list of integers
    each integer representing an initial set.
    Labels inside the file should start from 1.
    """

    # SOA calculation options - input in list
    soa_grps: Union[list, dict, None] = None  # Compute SOA for all if not given


@define(slots=True)
class GCKOption:
    """Options for running GECKO-A simulations."""

    path: str = "./vendor/boxmodel4gecko-v-1-0-genoa"  # Path to GECKO-A box model
    cmd_build: str = "./build --arch docker.gnu > tmptoto 2>&1"  # Command to build GECKO-A
    namelist: str = "./data/gecko-files/simu.nml"  # Default namelist
    nsim: int = 1  # Number of parallel simulations

    # GECKO-A specific options
    omp_num: Optional[int] = None  # Number of OpenMP threads


@define(slots=True)
class PostProcessOption:
    """Options for post-processing the simulation results."""

    # Names of the mechanisms
    mech_names: list = field(factory=list)
    # Paths to the simulation results
    mech_respaths: Union[list, str] = field(factory=list)
    # Paths to the mechanisms
    mech_paths: Optional[list] = None
    # Labels to save results
    mech_labels: Optional[list] = None

    # Unit for post-processing: 'ug', 'ppb', 'molec', 'ppbC'
    unit: str = "ppb"

    # Directory to save plots
    savpath: str = "./output/postprocess/plots"

    # Without primary VOCs
    tag_wopvoc: int = 1
    # Output csv files for plots
    tag_csv: int = 0
    # Add plots for normalized data
    tag_wnorm: int = 0
    # Merge plots from different conditions
    tag_merge: int = 0

    # Different types of plots
    plots: Optional[dict] = None  # Updated later
    plot_time_series: Optional[list] = None
    plot_gp_distribution: Optional[int] = None
    plot_volatility: Optional[list] = None
    plot_reactivity: Optional[list] = None
    plot_ratios: Optional[list] = None
    plot_functional_group: Optional[list] = None
    plot_carbon: Optional[list] = None
    plot_hc_nox_ratio: Optional[list] = None
    # Mechanism comparison
    plot_mech_cmp: Union[str, list, None] = None
    plot_mech_cmp2: Optional[list] = None

    # Error computation
    err_ref_mech: Optional[str] = None  # Reference mechanism
    err_types: Union[str, list, None] = None  # Error type: used only when err_ref_chem is given

    # Record files post-processing
    plot_reduction: Optional[list] = None
    plot_flowchart: Optional[list] = None

    logt: Optional[RecordOption] = None  # Record file
    cdata: Optional[list] = None  # Data for post-processing across the conditions

    def update_plot_dict(self) -> None:
        """Update the plot dictionary."""
        self.plots = {k[5:]: v for k, v in asdict(self).items() if k.startswith("plot_") and v is not None}
        if not self.plots:
            self.plots["no_plot"] = True
            return

        logger.info("Read plot types: %s", self.plots.keys())

        for k in ["reduction", "flowchart"]:  # Remove
            self.plots.pop(k, None)

        if not self.plots:
            self.plots["no_res_plot"] = True


@define(slots=True)
class TbrOption:
    """Options for threshold-based reduction (TBR)."""

    # id for threshold-based reduction
    runid: str = "TBR"

    # Mechanism name: if not given generate from id and prefix
    mech_name: Optional[str] = None

    # Reference mechanism
    ref_mech_name: Optional[str] = None  # Reference mechanism name
    ref_mech_path: Optional[str] = None  # Reference mechanism path

    # Threshold-based reduction settings
    remove_pvoc_gp: int = 1  # Remove gas-phase partitioning for primary VOCs or not
    carbon_balance: int = 0  # Preserve carbon balance or not
    tag_sim: int = 0  # Run simulation with threshold-reduced mechanism or not
    ntry: int = 1  # Maximum number of tries for each strategy
    tag_save_all: int = 0  # Save all tried threshold-reduced mechanisms or not

    # Available threshold-based strategy; default value. None for no reduction
    # Jump species with lifetime < tau (s); 1
    lifetime: Optional[float] = None
    # Remove products with yield < yield in single-generation reactions
    pyield: Optional[float] = None
    # Remove species with product yield < pyield in reaction time 3600s.
    pyield_tree: Optional[float] = None
    # Remove reactions with branching ratios < bratio; 0.001
    bratio: Optional[float] = None
    # Remove reactions with No. generation > generation (#); 10
    generation: Optional[int] = None
    # Set species with Psat <= nvoc (atm) to non-volatile; 1E-13
    nvoc: Optional[float] = None
    # Set species with Psat > svoc (atm) to volatile; 1E-3
    svoc: Optional[float] = None
    # Remove children reactions/species from non-volatile species with Psat <= nvoc_tree; 1E-13
    nvoc_tree: Optional[float] = None
    # Remove species from a branch where all species are with Psat > svoc_tree (atm); 1E-3
    svoc_tree: Optional[float] = None
    # Remove species from a branch where all species are with conc < conc_tree (ug/cm3); 1E-3
    conc_tree: Optional[float] = None
    # Remove species based on the input information from the user
    extra_sps_rdc: Optional[list] = None

    # Perform reduction with the given strategies
    # Settings see reduction_setting.py
    lumping: Union[bool, str] = False
    jumping: bool = False
    replacement: bool = False
    nsmax: Optional[int] = None  # Maximum number of species in a group
    ngmax: Optional[int] = None  # Maximum number of groups

    # Prepare lists for reduction
    given_groups: Optional[dict] = None
    target_species: list = field(factory=list)

    loge: Optional[RecordOption] = None  # Error record

    # Get threshold-based reduction in order
    def get_valid_in_order(self) -> List[str]:
        """
        Get the valid reduction strategies in order.

        Returns:
            List[str]: The valid reduction strategies in order.
        """
        rdc_attr = {"lumping": "lp", "jumping": "jp", "replacement": "rp"}
        return [[rdc_attr.get(k, k), getattr(self, k)] for k in tbr_order if getattr(self, k)]


@define(slots=True)
class TestingOption:
    """Options for testing the mechanism."""

    runid: str = "TST"  # Running id

    # Testing conditions
    path_cond: str = ""  # Condition path
    conds: List[str] = field(factory=list)  # Conditions after processed

    # Mechanisms
    mech_name: str = ""  # Testing mechanism name
    mech_path: str = ""  # Testing mechanism path
    ref_mech_name: str = ""  # Reference mechanism name
    ref_mech_path: str = ""  # Reference mechanism path
    read_ref: Optional[str] = None  # Folder name to reuse testing results

    # Conduct simulation
    path_work: Optional[str] = None  # Working path for testing
    loge: Optional[RecordOption] = None  # Error record

    # Simulation settings
    sml: Optional["RunSmlSetting"] = None


@define(slots=True)
class TrainingOption:
    """Options for training the mechanism."""

    runid: str = "TRN"  # Running id
    runame: Optional[str] = None  # Running name
    training_parameter_table: Optional[str] = None  # csv filepath to input parameters

    # Time limit and restart
    tlim: Optional[int] = None  # Time limit in seconds
    tstart: int = 0  # Time start
    # Restart files as given file path (str), use default (int != 0), not use (int == 0)
    restart_from: Union[str, int] = 0  # Restart from a specific file
    restart_to: Optional[str] = None  # Restart to a specific file - Set in training

    # Cleaning option
    clean_tmp: int = 1  # Clean temporary files or not

    # Reduction order mode - check TRN_MODE code
    # "gen_prop" - generate orders based on species properties
    # "gen_delete" - generate orders based on species deletion
    # "read_[file_path]"  or "[file_path]" - read orders from a file
    group_order_mode: str = "gen_prop"  # Default
    group_order_file: Optional[str] = None  # File to read orders
    nsps_group: int = 0  # Max number of species in a group if > 0

    # Species list
    frozen_species: list = field(factory=list)  # Frozen without reduction
    kept_species: list = field(factory=list)  # Kept in the reduced mechanisms - can be changed
    kept_all: list = field(factory=list)  # Generated during the run

    npara: int = 1  # Number of CPUs for writing mechanisms: series if <= 1
    ave_err_approach: Optional[float] = None  # Error scale down

    # Reference mechanism, if not given, use the starting mechanism
    ref_mech_name: Optional[str] = None  # Also the mechanism for pre-testing
    ref_mech_path: Optional[str] = None
    mech_name: Optional[str] = None  # Starting mechanism name
    mech_path: Optional[str] = None  # Starting mechanism path
    mechs: Optional[list] = None  # [Ref, Pre]

    # Options for trimming the mechanism
    trim_opts: dict = {"clean": "wgen"}
    with_merge: int = 1

    # Pre-testing - Evaluate reduced mechanism after each reduction cycle
    pretesting: Optional[TestingOption] = None  # Pre-testing option
    pretesting_path: Optional[str] = None  # Pre-testing conditions
    stop_at_eave: float = 99.0  # Tolerance on mean error
    stop_at_emax: float = 99.0  # Tolerance on max error

    # ---- Parameters that can be read from csv file ----
    strategies: Optional[list] = None  # Reduction strategies
    path_cond: Optional[str] = None  # Path to training conditions

    # Error tolerance
    err_files: Optional[list] = ["ref", "pre"]  # Error reference files
    err_max: Optional[list] = [0.01, 0.03, 0.03, 0.10]  # Maximum error
    err_ave: Optional[list] = [0.01, 0.01, 0.03, 0.10]  # Average error
    delta_err: Optional[float] = 0.001  # Tolerance for error increase

    # ---- Initialize inside training ----
    params_dict: Optional[dict] = None  # Parameters for reduction cycles
    ref_concs: Optional[dict] = None  # Reference concentrations

    # Paths for temporary files
    paths: Optional[FolderPath] = None  # Paths for training
    path_work: str = ""  # Working path for training
    path_mech: str = ""  # Path to save mechanisms

    # Record Training
    logt: Optional[RecordOption] = None  # Track file


@define(slots=True)
class EnvOption:
    """Options for setting the environment parameters."""

    # Temperature sets
    temps: List[float] = [298.0, 253.0, 273.0, 293.0, 313.0]
    # Pressure sets
    press: List[float] = [2.55e19]
    # Relative humidity sets
    rhs: List[float] = [0.70]
    # Solar zenith angles
    azis: List[float] = [0.0, 45.0]

    # Photolysis file used by kinetic with 'PHOT' keyword
    photolysis_file: str = "./data/gecko-files/solarlight.phot"


def check_and_set_attr(obj: Any, key: str, value: Any) -> bool:
    """
    Check if the object has the attribute and set it if exists.

    Args:
        obj: The object to set the attribute on.
        key: The attribute name to check and set.
        value: The value to set for the attribute.

    Returns:
        bool: True if the attribute was set, False otherwise.
    """
    if hasattr(obj, key):
        setattr(obj, key, value)
        return True

    return False
